//
//  PokeDexPresenter.swift
//  PokedexBCI
//
//  Created Irwin Bravo Oporto on 1/04/25.
//  Copyright © 2025 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Nishi
//

import UIKit

class PokeDexPresenter {
    // MARK: - Properties
    weak private var view: PokeDexViewProtocol?
    var interactor: PokeDexInteractorInputProtocol?
    private let router: PokeDexWireframeProtocol
    
    private var pokemons: [ResultPokeDex] = []
    private var filteredPokemons: [ResultPokeDex] = []
    private var isSearching = false
    
    // MARK: - Initialization
    init(interface: PokeDexViewProtocol, interactor: PokeDexInteractorInputProtocol?, router: PokeDexWireframeProtocol) {
        self.view = interface
        self.interactor = interactor
        self.router = router
    }
    
}

// MARK: - PokeDexPresenterProtocol
extension PokeDexPresenter: PokeDexPresenterProtocol {
    func viewDidLoad() {
        view?.playBackgroundAnimation()
        loadPokemons()
    }
    
    func loadPokemons() {
        view?.showLoading()
        interactor?.fetchAllPokemons { [weak self] result in
            DispatchQueue.main.async {
                self?.view?.hideLoading()
                switch result {
                case .success(let pokemons):
                    self?.pokemons = pokemons
                    self?.filteredPokemons = pokemons
                    self?.view?.reloadCollectionView()
                case .failure(let error):
                    self?.view?.showError(message: error.localizedDescription)
                }
            }
        }
    }
    
    func cancelSearch() {
        isSearching = false
        filteredPokemons = pokemons
        view?.reloadCollectionView()
    }
    
    func searchPokemon(with text: String) {
        if text.isEmpty {
            filteredPokemons = pokemons
        } else {
            filteredPokemons = pokemons.filter {
                $0.name?.lowercased().contains(text.lowercased()) ?? false
            }
        }
        view?.reloadCollectionView()
    }
    
    func didSelectPokemon(at index: Int) {
        guard let pokemon = pokemon(at: index) else { return }
        router.navigateToPokemonDetail(from: view, with: pokemon)
    }
    
    var numberOfPokemons: Int {
        return filteredPokemons.count
    }
    
    func pokemon(at index: Int) -> ResultPokeDex? {
        guard index < filteredPokemons.count else { return nil }
        return filteredPokemons[index]
    }
}

// MARK: - PokeDexInteractorOutputProtocol
extension PokeDexPresenter: PokeDexInteractorOutputProtocol {
    // Implementa métodos de respuesta del interactor si es necesario
}
